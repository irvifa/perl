=begin comment

Kubernetes

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: v1.14.6

Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package Kubernetes::Object::V1PersistentVolumeSpec;

require 5.6.0;
use strict;
use warnings;
use utf8;
use JSON qw(decode_json);
use Data::Dumper;
use Module::Runtime qw(use_module);
use Log::Any qw($log);
use Date::Parse;
use DateTime;

use Kubernetes::Object::V1AWSElasticBlockStoreVolumeSource;
use Kubernetes::Object::V1AzureDiskVolumeSource;
use Kubernetes::Object::V1AzureFilePersistentVolumeSource;
use Kubernetes::Object::V1CSIPersistentVolumeSource;
use Kubernetes::Object::V1CephFSPersistentVolumeSource;
use Kubernetes::Object::V1CinderPersistentVolumeSource;
use Kubernetes::Object::V1FCVolumeSource;
use Kubernetes::Object::V1FlexPersistentVolumeSource;
use Kubernetes::Object::V1FlockerVolumeSource;
use Kubernetes::Object::V1GCEPersistentDiskVolumeSource;
use Kubernetes::Object::V1GlusterfsPersistentVolumeSource;
use Kubernetes::Object::V1HostPathVolumeSource;
use Kubernetes::Object::V1ISCSIPersistentVolumeSource;
use Kubernetes::Object::V1LocalVolumeSource;
use Kubernetes::Object::V1NFSVolumeSource;
use Kubernetes::Object::V1ObjectReference;
use Kubernetes::Object::V1PhotonPersistentDiskVolumeSource;
use Kubernetes::Object::V1PortworxVolumeSource;
use Kubernetes::Object::V1QuobyteVolumeSource;
use Kubernetes::Object::V1RBDPersistentVolumeSource;
use Kubernetes::Object::V1ScaleIOPersistentVolumeSource;
use Kubernetes::Object::V1StorageOSPersistentVolumeSource;
use Kubernetes::Object::V1VolumeNodeAffinity;
use Kubernetes::Object::V1VsphereVirtualDiskVolumeSource;

use base ("Class::Accessor", "Class::Data::Inheritable");

#
#PersistentVolumeSpec is the specification of a persistent volume.
#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech). Do not edit the class manually.
# REF: https://openapi-generator.tech
#

=begin comment

Kubernetes

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: v1.14.6

Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
__PACKAGE__->mk_classdata('attribute_map' => {});
__PACKAGE__->mk_classdata('openapi_types' => {});
__PACKAGE__->mk_classdata('method_documentation' => {}); 
__PACKAGE__->mk_classdata('class_documentation' => {});

# new plain object
sub new { 
    my ($class, %args) = @_; 

    my $self = bless {}, $class;

    $self->init(%args);
    
    return $self;
}

# initialize the object
sub init
{
    my ($self, %args) = @_;

    foreach my $attribute (keys %{$self->attribute_map}) {
        my $args_key = $self->attribute_map->{$attribute};
        $self->$attribute( $args{ $args_key } );
    }
}

# return perl hash
sub to_hash {
    my $self = shift;
    my $_hash = decode_json(JSON->new->convert_blessed->encode($self));

    return $_hash;
}

# used by JSON for serialization
sub TO_JSON { 
    my $self = shift;
    my $_data = {};
    foreach my $_key (keys %{$self->attribute_map}) {
        if (defined $self->{$_key}) {
            $_data->{$self->attribute_map->{$_key}} = $self->{$_key};
        }
    }

    return $_data;
}

# from Perl hashref
sub from_hash {
    my ($self, $hash) = @_;

    # loop through attributes and use openapi_types to deserialize the data
    while ( my ($_key, $_type) = each %{$self->openapi_types} ) {
        my $_json_attribute = $self->attribute_map->{$_key}; 
        if ($_type =~ /^array\[(.+)\]$/i) { # array
            my $_subclass = $1;
            my @_array = ();
            foreach my $_element (@{$hash->{$_json_attribute}}) {
                push @_array, $self->_deserialize($_subclass, $_element);
            }
            $self->{$_key} = \@_array;
        } elsif ($_type =~ /^hash\[string,(.+)\]$/i) { # hash
            my $_subclass = $1;
            my %_hash = ();
            while (my($_key, $_element) = each %{$hash->{$_json_attribute}}) {
                $_hash{$_key} = $self->_deserialize($_subclass, $_element);
            }
            $self->{$_key} = \%_hash;
        } elsif (exists $hash->{$_json_attribute}) { #hash(model), primitive, datetime
            $self->{$_key} = $self->_deserialize($_type, $hash->{$_json_attribute});
        } else {
            $log->debugf("Warning: %s (%s) does not exist in input hash\n", $_key, $_json_attribute);
        }
    }
  
    return $self;
}

# deserialize non-array data
sub _deserialize {
    my ($self, $type, $data) = @_;
    $log->debugf("deserializing %s with %s",Dumper($data), $type);

    if ($type eq 'DateTime') {
        return DateTime->from_epoch(epoch => str2time($data));
    } elsif ( grep( /^$type$/, ('int', 'double', 'string', 'boolean'))) {
        return $data;
    } else { # hash(model)
        my $_instance = eval "Kubernetes::Object::$type->new()";
        return $_instance->from_hash($data);
    }
}



__PACKAGE__->class_documentation({description => 'PersistentVolumeSpec is the specification of a persistent volume.',
                                  class => 'V1PersistentVolumeSpec',
                                  required => [], # TODO
}                                 );

__PACKAGE__->method_documentation({
    'access_modes' => {
        datatype => 'ARRAY[string]',
        base_name => 'accessModes',
        description => 'AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes',
        format => '',
        read_only => '',
            },
    'aws_elastic_block_store' => {
        datatype => 'V1AWSElasticBlockStoreVolumeSource',
        base_name => 'awsElasticBlockStore',
        description => '',
        format => '',
        read_only => '',
            },
    'azure_disk' => {
        datatype => 'V1AzureDiskVolumeSource',
        base_name => 'azureDisk',
        description => '',
        format => '',
        read_only => '',
            },
    'azure_file' => {
        datatype => 'V1AzureFilePersistentVolumeSource',
        base_name => 'azureFile',
        description => '',
        format => '',
        read_only => '',
            },
    'capacity' => {
        datatype => 'HASH[string,string]',
        base_name => 'capacity',
        description => 'A description of the persistent volume&#39;s resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity',
        format => '',
        read_only => '',
            },
    'cephfs' => {
        datatype => 'V1CephFSPersistentVolumeSource',
        base_name => 'cephfs',
        description => '',
        format => '',
        read_only => '',
            },
    'cinder' => {
        datatype => 'V1CinderPersistentVolumeSource',
        base_name => 'cinder',
        description => '',
        format => '',
        read_only => '',
            },
    'claim_ref' => {
        datatype => 'V1ObjectReference',
        base_name => 'claimRef',
        description => '',
        format => '',
        read_only => '',
            },
    'csi' => {
        datatype => 'V1CSIPersistentVolumeSource',
        base_name => 'csi',
        description => '',
        format => '',
        read_only => '',
            },
    'fc' => {
        datatype => 'V1FCVolumeSource',
        base_name => 'fc',
        description => '',
        format => '',
        read_only => '',
            },
    'flex_volume' => {
        datatype => 'V1FlexPersistentVolumeSource',
        base_name => 'flexVolume',
        description => '',
        format => '',
        read_only => '',
            },
    'flocker' => {
        datatype => 'V1FlockerVolumeSource',
        base_name => 'flocker',
        description => '',
        format => '',
        read_only => '',
            },
    'gce_persistent_disk' => {
        datatype => 'V1GCEPersistentDiskVolumeSource',
        base_name => 'gcePersistentDisk',
        description => '',
        format => '',
        read_only => '',
            },
    'glusterfs' => {
        datatype => 'V1GlusterfsPersistentVolumeSource',
        base_name => 'glusterfs',
        description => '',
        format => '',
        read_only => '',
            },
    'host_path' => {
        datatype => 'V1HostPathVolumeSource',
        base_name => 'hostPath',
        description => '',
        format => '',
        read_only => '',
            },
    'iscsi' => {
        datatype => 'V1ISCSIPersistentVolumeSource',
        base_name => 'iscsi',
        description => '',
        format => '',
        read_only => '',
            },
    'local' => {
        datatype => 'V1LocalVolumeSource',
        base_name => 'local',
        description => '',
        format => '',
        read_only => '',
            },
    'mount_options' => {
        datatype => 'ARRAY[string]',
        base_name => 'mountOptions',
        description => 'A list of mount options, e.g. [\&quot;ro\&quot;, \&quot;soft\&quot;]. Not validated - mount will simply fail if one is invalid. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options',
        format => '',
        read_only => '',
            },
    'nfs' => {
        datatype => 'V1NFSVolumeSource',
        base_name => 'nfs',
        description => '',
        format => '',
        read_only => '',
            },
    'node_affinity' => {
        datatype => 'V1VolumeNodeAffinity',
        base_name => 'nodeAffinity',
        description => '',
        format => '',
        read_only => '',
            },
    'persistent_volume_reclaim_policy' => {
        datatype => 'string',
        base_name => 'persistentVolumeReclaimPolicy',
        description => 'What happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created PersistentVolumes), Delete (default for dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this PersistentVolume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming',
        format => '',
        read_only => '',
            },
    'photon_persistent_disk' => {
        datatype => 'V1PhotonPersistentDiskVolumeSource',
        base_name => 'photonPersistentDisk',
        description => '',
        format => '',
        read_only => '',
            },
    'portworx_volume' => {
        datatype => 'V1PortworxVolumeSource',
        base_name => 'portworxVolume',
        description => '',
        format => '',
        read_only => '',
            },
    'quobyte' => {
        datatype => 'V1QuobyteVolumeSource',
        base_name => 'quobyte',
        description => '',
        format => '',
        read_only => '',
            },
    'rbd' => {
        datatype => 'V1RBDPersistentVolumeSource',
        base_name => 'rbd',
        description => '',
        format => '',
        read_only => '',
            },
    'scale_io' => {
        datatype => 'V1ScaleIOPersistentVolumeSource',
        base_name => 'scaleIO',
        description => '',
        format => '',
        read_only => '',
            },
    'storage_class_name' => {
        datatype => 'string',
        base_name => 'storageClassName',
        description => 'Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.',
        format => '',
        read_only => '',
            },
    'storageos' => {
        datatype => 'V1StorageOSPersistentVolumeSource',
        base_name => 'storageos',
        description => '',
        format => '',
        read_only => '',
            },
    'volume_mode' => {
        datatype => 'string',
        base_name => 'volumeMode',
        description => 'volumeMode defines if a volume is intended to be used with a formatted filesystem or to remain in raw block state. Value of Filesystem is implied when not included in spec. This is a beta feature.',
        format => '',
        read_only => '',
            },
    'vsphere_volume' => {
        datatype => 'V1VsphereVirtualDiskVolumeSource',
        base_name => 'vsphereVolume',
        description => '',
        format => '',
        read_only => '',
            },
});

__PACKAGE__->openapi_types( {
    'access_modes' => 'ARRAY[string]',
    'aws_elastic_block_store' => 'V1AWSElasticBlockStoreVolumeSource',
    'azure_disk' => 'V1AzureDiskVolumeSource',
    'azure_file' => 'V1AzureFilePersistentVolumeSource',
    'capacity' => 'HASH[string,string]',
    'cephfs' => 'V1CephFSPersistentVolumeSource',
    'cinder' => 'V1CinderPersistentVolumeSource',
    'claim_ref' => 'V1ObjectReference',
    'csi' => 'V1CSIPersistentVolumeSource',
    'fc' => 'V1FCVolumeSource',
    'flex_volume' => 'V1FlexPersistentVolumeSource',
    'flocker' => 'V1FlockerVolumeSource',
    'gce_persistent_disk' => 'V1GCEPersistentDiskVolumeSource',
    'glusterfs' => 'V1GlusterfsPersistentVolumeSource',
    'host_path' => 'V1HostPathVolumeSource',
    'iscsi' => 'V1ISCSIPersistentVolumeSource',
    'local' => 'V1LocalVolumeSource',
    'mount_options' => 'ARRAY[string]',
    'nfs' => 'V1NFSVolumeSource',
    'node_affinity' => 'V1VolumeNodeAffinity',
    'persistent_volume_reclaim_policy' => 'string',
    'photon_persistent_disk' => 'V1PhotonPersistentDiskVolumeSource',
    'portworx_volume' => 'V1PortworxVolumeSource',
    'quobyte' => 'V1QuobyteVolumeSource',
    'rbd' => 'V1RBDPersistentVolumeSource',
    'scale_io' => 'V1ScaleIOPersistentVolumeSource',
    'storage_class_name' => 'string',
    'storageos' => 'V1StorageOSPersistentVolumeSource',
    'volume_mode' => 'string',
    'vsphere_volume' => 'V1VsphereVirtualDiskVolumeSource'
} );

__PACKAGE__->attribute_map( {
    'access_modes' => 'accessModes',
    'aws_elastic_block_store' => 'awsElasticBlockStore',
    'azure_disk' => 'azureDisk',
    'azure_file' => 'azureFile',
    'capacity' => 'capacity',
    'cephfs' => 'cephfs',
    'cinder' => 'cinder',
    'claim_ref' => 'claimRef',
    'csi' => 'csi',
    'fc' => 'fc',
    'flex_volume' => 'flexVolume',
    'flocker' => 'flocker',
    'gce_persistent_disk' => 'gcePersistentDisk',
    'glusterfs' => 'glusterfs',
    'host_path' => 'hostPath',
    'iscsi' => 'iscsi',
    'local' => 'local',
    'mount_options' => 'mountOptions',
    'nfs' => 'nfs',
    'node_affinity' => 'nodeAffinity',
    'persistent_volume_reclaim_policy' => 'persistentVolumeReclaimPolicy',
    'photon_persistent_disk' => 'photonPersistentDisk',
    'portworx_volume' => 'portworxVolume',
    'quobyte' => 'quobyte',
    'rbd' => 'rbd',
    'scale_io' => 'scaleIO',
    'storage_class_name' => 'storageClassName',
    'storageos' => 'storageos',
    'volume_mode' => 'volumeMode',
    'vsphere_volume' => 'vsphereVolume'
} );

__PACKAGE__->mk_accessors(keys %{__PACKAGE__->attribute_map});


1;
