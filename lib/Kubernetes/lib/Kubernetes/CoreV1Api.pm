=begin comment

Kubernetes

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: v1.14.6

Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package Kubernetes::CoreV1Api;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use Kubernetes::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'Kubernetes::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = Kubernetes::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# connect_delete_namespaced_pod_proxy
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_delete_namespaced_pod_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_delete_namespaced_pod_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_delete_namespaced_pod_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_delete_namespaced_pod_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_delete_namespaced_pod_proxy_with_path
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_delete_namespaced_pod_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_delete_namespaced_pod_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_delete_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_delete_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_delete_namespaced_pod_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_delete_namespaced_service_proxy
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_delete_namespaced_service_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_delete_namespaced_service_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_delete_namespaced_service_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_delete_namespaced_service_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_delete_namespaced_service_proxy_with_path
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_delete_namespaced_service_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_delete_namespaced_service_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_delete_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_delete_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_delete_namespaced_service_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_delete_node_proxy
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_delete_node_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_delete_node_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_delete_node_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_delete_node_proxy_with_path
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_delete_node_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_delete_node_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_delete_node_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_delete_node_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy/{path}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_get_namespaced_pod_attach
#
# 
# 
# @param string $name name of the PodAttachOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $container The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
# @param boolean $stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)
# @param boolean $stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)
# @param boolean $stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)
# @param boolean $tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodAttachOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'container' => {
        data_type => 'string',
        description => 'The container in which to execute the command. Defaults to only container if there is only one container in the pod.',
        required => '0',
    },
    'stderr' => {
        data_type => 'boolean',
        description => 'Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.',
        required => '0',
    },
    'stdin' => {
        data_type => 'boolean',
        description => 'Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.',
        required => '0',
    },
    'stdout' => {
        data_type => 'boolean',
        description => 'Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.',
        required => '0',
    },
    'tty' => {
        data_type => 'boolean',
        description => 'TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_get_namespaced_pod_attach' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_get_namespaced_pod_attach {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_get_namespaced_pod_attach");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_get_namespaced_pod_attach");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/attach';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'container'}) {
        $query_params->{'container'} = $self->{api_client}->to_query_value($args{'container'});
    }

    # query params
    if ( exists $args{'stderr'}) {
        $query_params->{'stderr'} = $self->{api_client}->to_query_value($args{'stderr'});
    }

    # query params
    if ( exists $args{'stdin'}) {
        $query_params->{'stdin'} = $self->{api_client}->to_query_value($args{'stdin'});
    }

    # query params
    if ( exists $args{'stdout'}) {
        $query_params->{'stdout'} = $self->{api_client}->to_query_value($args{'stdout'});
    }

    # query params
    if ( exists $args{'tty'}) {
        $query_params->{'tty'} = $self->{api_client}->to_query_value($args{'tty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_get_namespaced_pod_exec
#
# 
# 
# @param string $name name of the PodExecOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $command Command is the remote command to execute. argv array. Not executed within a shell. (optional)
# @param string $container Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
# @param boolean $stderr Redirect the standard error stream of the pod for this call. Defaults to true. (optional)
# @param boolean $stdin Redirect the standard input stream of the pod for this call. Defaults to false. (optional)
# @param boolean $stdout Redirect the standard output stream of the pod for this call. Defaults to true. (optional)
# @param boolean $tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodExecOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'command' => {
        data_type => 'string',
        description => 'Command is the remote command to execute. argv array. Not executed within a shell.',
        required => '0',
    },
    'container' => {
        data_type => 'string',
        description => 'Container in which to execute the command. Defaults to only container if there is only one container in the pod.',
        required => '0',
    },
    'stderr' => {
        data_type => 'boolean',
        description => 'Redirect the standard error stream of the pod for this call. Defaults to true.',
        required => '0',
    },
    'stdin' => {
        data_type => 'boolean',
        description => 'Redirect the standard input stream of the pod for this call. Defaults to false.',
        required => '0',
    },
    'stdout' => {
        data_type => 'boolean',
        description => 'Redirect the standard output stream of the pod for this call. Defaults to true.',
        required => '0',
    },
    'tty' => {
        data_type => 'boolean',
        description => 'TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_get_namespaced_pod_exec' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_get_namespaced_pod_exec {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_get_namespaced_pod_exec");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_get_namespaced_pod_exec");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/exec';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'command'}) {
        $query_params->{'command'} = $self->{api_client}->to_query_value($args{'command'});
    }

    # query params
    if ( exists $args{'container'}) {
        $query_params->{'container'} = $self->{api_client}->to_query_value($args{'container'});
    }

    # query params
    if ( exists $args{'stderr'}) {
        $query_params->{'stderr'} = $self->{api_client}->to_query_value($args{'stderr'});
    }

    # query params
    if ( exists $args{'stdin'}) {
        $query_params->{'stdin'} = $self->{api_client}->to_query_value($args{'stdin'});
    }

    # query params
    if ( exists $args{'stdout'}) {
        $query_params->{'stdout'} = $self->{api_client}->to_query_value($args{'stdout'});
    }

    # query params
    if ( exists $args{'tty'}) {
        $query_params->{'tty'} = $self->{api_client}->to_query_value($args{'tty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_get_namespaced_pod_portforward
#
# 
# 
# @param string $name name of the PodPortForwardOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param int $ports List of ports to forward Required when using WebSockets (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodPortForwardOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'ports' => {
        data_type => 'int',
        description => 'List of ports to forward Required when using WebSockets',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_get_namespaced_pod_portforward' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_get_namespaced_pod_portforward {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_get_namespaced_pod_portforward");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_get_namespaced_pod_portforward");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/portforward';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'ports'}) {
        $query_params->{'ports'} = $self->{api_client}->to_query_value($args{'ports'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_get_namespaced_pod_proxy
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_get_namespaced_pod_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_get_namespaced_pod_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_get_namespaced_pod_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_get_namespaced_pod_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_get_namespaced_pod_proxy_with_path
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_get_namespaced_pod_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_get_namespaced_pod_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_get_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_get_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_get_namespaced_pod_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_get_namespaced_service_proxy
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_get_namespaced_service_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_get_namespaced_service_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_get_namespaced_service_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_get_namespaced_service_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_get_namespaced_service_proxy_with_path
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_get_namespaced_service_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_get_namespaced_service_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_get_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_get_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_get_namespaced_service_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_get_node_proxy
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_get_node_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_get_node_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_get_node_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_get_node_proxy_with_path
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_get_node_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_get_node_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_get_node_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_get_node_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy/{path}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_head_namespaced_pod_proxy
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_head_namespaced_pod_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_head_namespaced_pod_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_head_namespaced_pod_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_head_namespaced_pod_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';

    my $_method = 'HEAD';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_head_namespaced_pod_proxy_with_path
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_head_namespaced_pod_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_head_namespaced_pod_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_head_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_head_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_head_namespaced_pod_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

    my $_method = 'HEAD';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_head_namespaced_service_proxy
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_head_namespaced_service_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_head_namespaced_service_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_head_namespaced_service_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_head_namespaced_service_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy';

    my $_method = 'HEAD';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_head_namespaced_service_proxy_with_path
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_head_namespaced_service_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_head_namespaced_service_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_head_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_head_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_head_namespaced_service_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

    my $_method = 'HEAD';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_head_node_proxy
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_head_node_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_head_node_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_head_node_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy';

    my $_method = 'HEAD';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_head_node_proxy_with_path
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_head_node_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_head_node_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_head_node_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_head_node_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy/{path}';

    my $_method = 'HEAD';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_options_namespaced_pod_proxy
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_options_namespaced_pod_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_options_namespaced_pod_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_options_namespaced_pod_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_options_namespaced_pod_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';

    my $_method = 'OPTIONS';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_options_namespaced_pod_proxy_with_path
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_options_namespaced_pod_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_options_namespaced_pod_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_options_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_options_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_options_namespaced_pod_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

    my $_method = 'OPTIONS';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_options_namespaced_service_proxy
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_options_namespaced_service_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_options_namespaced_service_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_options_namespaced_service_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_options_namespaced_service_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy';

    my $_method = 'OPTIONS';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_options_namespaced_service_proxy_with_path
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_options_namespaced_service_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_options_namespaced_service_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_options_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_options_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_options_namespaced_service_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

    my $_method = 'OPTIONS';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_options_node_proxy
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_options_node_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_options_node_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_options_node_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy';

    my $_method = 'OPTIONS';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_options_node_proxy_with_path
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_options_node_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_options_node_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_options_node_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_options_node_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy/{path}';

    my $_method = 'OPTIONS';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_patch_namespaced_pod_proxy
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_patch_namespaced_pod_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_patch_namespaced_pod_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_patch_namespaced_pod_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_patch_namespaced_pod_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_patch_namespaced_pod_proxy_with_path
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_patch_namespaced_pod_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_patch_namespaced_pod_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_patch_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_patch_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_patch_namespaced_pod_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_patch_namespaced_service_proxy
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_patch_namespaced_service_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_patch_namespaced_service_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_patch_namespaced_service_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_patch_namespaced_service_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_patch_namespaced_service_proxy_with_path
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_patch_namespaced_service_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_patch_namespaced_service_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_patch_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_patch_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_patch_namespaced_service_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_patch_node_proxy
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_patch_node_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_patch_node_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_patch_node_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_patch_node_proxy_with_path
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_patch_node_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_patch_node_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_patch_node_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_patch_node_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy/{path}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_post_namespaced_pod_attach
#
# 
# 
# @param string $name name of the PodAttachOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $container The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
# @param boolean $stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)
# @param boolean $stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)
# @param boolean $stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)
# @param boolean $tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodAttachOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'container' => {
        data_type => 'string',
        description => 'The container in which to execute the command. Defaults to only container if there is only one container in the pod.',
        required => '0',
    },
    'stderr' => {
        data_type => 'boolean',
        description => 'Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.',
        required => '0',
    },
    'stdin' => {
        data_type => 'boolean',
        description => 'Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.',
        required => '0',
    },
    'stdout' => {
        data_type => 'boolean',
        description => 'Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.',
        required => '0',
    },
    'tty' => {
        data_type => 'boolean',
        description => 'TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_post_namespaced_pod_attach' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_post_namespaced_pod_attach {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_post_namespaced_pod_attach");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_post_namespaced_pod_attach");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/attach';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'container'}) {
        $query_params->{'container'} = $self->{api_client}->to_query_value($args{'container'});
    }

    # query params
    if ( exists $args{'stderr'}) {
        $query_params->{'stderr'} = $self->{api_client}->to_query_value($args{'stderr'});
    }

    # query params
    if ( exists $args{'stdin'}) {
        $query_params->{'stdin'} = $self->{api_client}->to_query_value($args{'stdin'});
    }

    # query params
    if ( exists $args{'stdout'}) {
        $query_params->{'stdout'} = $self->{api_client}->to_query_value($args{'stdout'});
    }

    # query params
    if ( exists $args{'tty'}) {
        $query_params->{'tty'} = $self->{api_client}->to_query_value($args{'tty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_post_namespaced_pod_exec
#
# 
# 
# @param string $name name of the PodExecOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $command Command is the remote command to execute. argv array. Not executed within a shell. (optional)
# @param string $container Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
# @param boolean $stderr Redirect the standard error stream of the pod for this call. Defaults to true. (optional)
# @param boolean $stdin Redirect the standard input stream of the pod for this call. Defaults to false. (optional)
# @param boolean $stdout Redirect the standard output stream of the pod for this call. Defaults to true. (optional)
# @param boolean $tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodExecOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'command' => {
        data_type => 'string',
        description => 'Command is the remote command to execute. argv array. Not executed within a shell.',
        required => '0',
    },
    'container' => {
        data_type => 'string',
        description => 'Container in which to execute the command. Defaults to only container if there is only one container in the pod.',
        required => '0',
    },
    'stderr' => {
        data_type => 'boolean',
        description => 'Redirect the standard error stream of the pod for this call. Defaults to true.',
        required => '0',
    },
    'stdin' => {
        data_type => 'boolean',
        description => 'Redirect the standard input stream of the pod for this call. Defaults to false.',
        required => '0',
    },
    'stdout' => {
        data_type => 'boolean',
        description => 'Redirect the standard output stream of the pod for this call. Defaults to true.',
        required => '0',
    },
    'tty' => {
        data_type => 'boolean',
        description => 'TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_post_namespaced_pod_exec' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_post_namespaced_pod_exec {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_post_namespaced_pod_exec");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_post_namespaced_pod_exec");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/exec';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'command'}) {
        $query_params->{'command'} = $self->{api_client}->to_query_value($args{'command'});
    }

    # query params
    if ( exists $args{'container'}) {
        $query_params->{'container'} = $self->{api_client}->to_query_value($args{'container'});
    }

    # query params
    if ( exists $args{'stderr'}) {
        $query_params->{'stderr'} = $self->{api_client}->to_query_value($args{'stderr'});
    }

    # query params
    if ( exists $args{'stdin'}) {
        $query_params->{'stdin'} = $self->{api_client}->to_query_value($args{'stdin'});
    }

    # query params
    if ( exists $args{'stdout'}) {
        $query_params->{'stdout'} = $self->{api_client}->to_query_value($args{'stdout'});
    }

    # query params
    if ( exists $args{'tty'}) {
        $query_params->{'tty'} = $self->{api_client}->to_query_value($args{'tty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_post_namespaced_pod_portforward
#
# 
# 
# @param string $name name of the PodPortForwardOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param int $ports List of ports to forward Required when using WebSockets (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodPortForwardOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'ports' => {
        data_type => 'int',
        description => 'List of ports to forward Required when using WebSockets',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_post_namespaced_pod_portforward' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_post_namespaced_pod_portforward {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_post_namespaced_pod_portforward");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_post_namespaced_pod_portforward");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/portforward';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'ports'}) {
        $query_params->{'ports'} = $self->{api_client}->to_query_value($args{'ports'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_post_namespaced_pod_proxy
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_post_namespaced_pod_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_post_namespaced_pod_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_post_namespaced_pod_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_post_namespaced_pod_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_post_namespaced_pod_proxy_with_path
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_post_namespaced_pod_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_post_namespaced_pod_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_post_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_post_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_post_namespaced_pod_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_post_namespaced_service_proxy
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_post_namespaced_service_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_post_namespaced_service_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_post_namespaced_service_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_post_namespaced_service_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_post_namespaced_service_proxy_with_path
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_post_namespaced_service_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_post_namespaced_service_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_post_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_post_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_post_namespaced_service_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_post_node_proxy
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_post_node_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_post_node_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_post_node_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_post_node_proxy_with_path
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_post_node_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_post_node_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_post_node_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_post_node_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy/{path}';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_put_namespaced_pod_proxy
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_put_namespaced_pod_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_put_namespaced_pod_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_put_namespaced_pod_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_put_namespaced_pod_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_put_namespaced_pod_proxy_with_path
#
# 
# 
# @param string $name name of the PodProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to pod. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to pod.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_put_namespaced_pod_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_put_namespaced_pod_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_put_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_put_namespaced_pod_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_put_namespaced_pod_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_put_namespaced_service_proxy
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_put_namespaced_service_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_put_namespaced_service_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_put_namespaced_service_proxy");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_put_namespaced_service_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_put_namespaced_service_proxy_with_path
#
# 
# 
# @param string $name name of the ServiceProxyOptions (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceProxyOptions',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_put_namespaced_service_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_put_namespaced_service_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_put_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling connect_put_namespaced_service_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_put_namespaced_service_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_put_node_proxy
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_put_node_proxy' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_put_node_proxy {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_put_node_proxy");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# connect_put_node_proxy_with_path
#
# 
# 
# @param string $name name of the NodeProxyOptions (required)
# @param string $path path to the resource (required)
# @param string $path2 Path is the URL path to use for the current proxy request to node. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the NodeProxyOptions',
        required => '1',
    },
    'path' => {
        data_type => 'string',
        description => 'path to the resource',
        required => '1',
    },
    'path2' => {
        data_type => 'string',
        description => 'Path is the URL path to use for the current proxy request to node.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'connect_put_node_proxy_with_path' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub connect_put_node_proxy_with_path {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling connect_put_node_proxy_with_path");
    }

    # verify the required parameter 'path' is set
    unless (exists $args{'path'}) {
      croak("Missing the required parameter 'path' when calling connect_put_node_proxy_with_path");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/proxy/{path}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'path2'}) {
        $query_params->{'path'} = $self->{api_client}->to_query_value($args{'path2'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'path'}) {
        my $_base_variable = "{" . "path" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'path'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# create_namespace
#
# 
# 
# @param V1Namespace $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'body' => {
        data_type => 'V1Namespace',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespace' } = { 
        summary => '',
        params => $params,
        returns => 'V1Namespace',
        };
}
# @return V1Namespace
#
sub create_namespace {
    my ($self, %args) = @_;

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespace");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Namespace', $response);
    return $_response_object;
}

#
# create_namespaced_binding
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Binding $body  (required)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Binding',
        description => '',
        required => '1',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_binding' } = { 
        summary => '',
        params => $params,
        returns => 'V1Binding',
        };
}
# @return V1Binding
#
sub create_namespaced_binding {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_binding");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_binding");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/bindings';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Binding', $response);
    return $_response_object;
}

#
# create_namespaced_config_map
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ConfigMap $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ConfigMap',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_config_map' } = { 
        summary => '',
        params => $params,
        returns => 'V1ConfigMap',
        };
}
# @return V1ConfigMap
#
sub create_namespaced_config_map {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_config_map");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_config_map");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/configmaps';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ConfigMap', $response);
    return $_response_object;
}

#
# create_namespaced_endpoints
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Endpoints $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Endpoints',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_endpoints' } = { 
        summary => '',
        params => $params,
        returns => 'V1Endpoints',
        };
}
# @return V1Endpoints
#
sub create_namespaced_endpoints {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_endpoints");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_endpoints");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/endpoints';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Endpoints', $response);
    return $_response_object;
}

#
# create_namespaced_event
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Event $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Event',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_event' } = { 
        summary => '',
        params => $params,
        returns => 'V1Event',
        };
}
# @return V1Event
#
sub create_namespaced_event {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_event");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_event");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/events';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Event', $response);
    return $_response_object;
}

#
# create_namespaced_limit_range
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1LimitRange $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1LimitRange',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_limit_range' } = { 
        summary => '',
        params => $params,
        returns => 'V1LimitRange',
        };
}
# @return V1LimitRange
#
sub create_namespaced_limit_range {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_limit_range");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_limit_range");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/limitranges';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1LimitRange', $response);
    return $_response_object;
}

#
# create_namespaced_persistent_volume_claim
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1PersistentVolumeClaim $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1PersistentVolumeClaim',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_persistent_volume_claim' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeClaim',
        };
}
# @return V1PersistentVolumeClaim
#
sub create_namespaced_persistent_volume_claim {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_persistent_volume_claim");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_persistent_volume_claim");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeClaim', $response);
    return $_response_object;
}

#
# create_namespaced_pod
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Pod $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Pod',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_pod' } = { 
        summary => '',
        params => $params,
        returns => 'V1Pod',
        };
}
# @return V1Pod
#
sub create_namespaced_pod {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_pod");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_pod");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Pod', $response);
    return $_response_object;
}

#
# create_namespaced_pod_binding
#
# 
# 
# @param string $name name of the Binding (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Binding $body  (required)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Binding',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Binding',
        description => '',
        required => '1',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_pod_binding' } = { 
        summary => '',
        params => $params,
        returns => 'V1Binding',
        };
}
# @return V1Binding
#
sub create_namespaced_pod_binding {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling create_namespaced_pod_binding");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_pod_binding");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_pod_binding");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/binding';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Binding', $response);
    return $_response_object;
}

#
# create_namespaced_pod_eviction
#
# 
# 
# @param string $name name of the Eviction (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1beta1Eviction $body  (required)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Eviction',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1beta1Eviction',
        description => '',
        required => '1',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_pod_eviction' } = { 
        summary => '',
        params => $params,
        returns => 'V1beta1Eviction',
        };
}
# @return V1beta1Eviction
#
sub create_namespaced_pod_eviction {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling create_namespaced_pod_eviction");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_pod_eviction");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_pod_eviction");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/eviction';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1beta1Eviction', $response);
    return $_response_object;
}

#
# create_namespaced_pod_template
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1PodTemplate $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1PodTemplate',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_pod_template' } = { 
        summary => '',
        params => $params,
        returns => 'V1PodTemplate',
        };
}
# @return V1PodTemplate
#
sub create_namespaced_pod_template {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_pod_template");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_pod_template");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/podtemplates';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PodTemplate', $response);
    return $_response_object;
}

#
# create_namespaced_replication_controller
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ReplicationController $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ReplicationController',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_replication_controller' } = { 
        summary => '',
        params => $params,
        returns => 'V1ReplicationController',
        };
}
# @return V1ReplicationController
#
sub create_namespaced_replication_controller {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_replication_controller");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_replication_controller");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ReplicationController', $response);
    return $_response_object;
}

#
# create_namespaced_resource_quota
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ResourceQuota $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ResourceQuota',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_resource_quota' } = { 
        summary => '',
        params => $params,
        returns => 'V1ResourceQuota',
        };
}
# @return V1ResourceQuota
#
sub create_namespaced_resource_quota {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_resource_quota");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_resource_quota");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ResourceQuota', $response);
    return $_response_object;
}

#
# create_namespaced_secret
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Secret $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Secret',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_secret' } = { 
        summary => '',
        params => $params,
        returns => 'V1Secret',
        };
}
# @return V1Secret
#
sub create_namespaced_secret {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_secret");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_secret");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/secrets';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Secret', $response);
    return $_response_object;
}

#
# create_namespaced_service
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Service $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Service',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_service' } = { 
        summary => '',
        params => $params,
        returns => 'V1Service',
        };
}
# @return V1Service
#
sub create_namespaced_service {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_service");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_service");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Service', $response);
    return $_response_object;
}

#
# create_namespaced_service_account
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ServiceAccount $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ServiceAccount',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_namespaced_service_account' } = { 
        summary => '',
        params => $params,
        returns => 'V1ServiceAccount',
        };
}
# @return V1ServiceAccount
#
sub create_namespaced_service_account {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling create_namespaced_service_account");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_namespaced_service_account");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ServiceAccount', $response);
    return $_response_object;
}

#
# create_node
#
# 
# 
# @param V1Node $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'body' => {
        data_type => 'V1Node',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_node' } = { 
        summary => '',
        params => $params,
        returns => 'V1Node',
        };
}
# @return V1Node
#
sub create_node {
    my ($self, %args) = @_;

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_node");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Node', $response);
    return $_response_object;
}

#
# create_persistent_volume
#
# 
# 
# @param V1PersistentVolume $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'body' => {
        data_type => 'V1PersistentVolume',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_persistent_volume' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolume',
        };
}
# @return V1PersistentVolume
#
sub create_persistent_volume {
    my ($self, %args) = @_;

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling create_persistent_volume");
    }

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolume', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_config_map
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_config_map' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_config_map {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_config_map");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/configmaps';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_endpoints
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_endpoints' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_endpoints {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_endpoints");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/endpoints';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_event
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_event' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_event {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_event");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/events';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_limit_range
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_limit_range' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_limit_range {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_limit_range");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/limitranges';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_persistent_volume_claim
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_persistent_volume_claim' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_persistent_volume_claim {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_persistent_volume_claim");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_pod
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_pod' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_pod {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_pod");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_pod_template
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_pod_template' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_pod_template {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_pod_template");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/podtemplates';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_replication_controller
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_replication_controller' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_replication_controller {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_replication_controller");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_resource_quota
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_resource_quota' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_resource_quota {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_resource_quota");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_secret
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_secret' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_secret {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_secret");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/secrets';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_namespaced_service_account
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_namespaced_service_account' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_namespaced_service_account {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_collection_namespaced_service_account");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_node
#
# 
# 
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_node' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_node {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/nodes';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_collection_persistent_volume
#
# 
# 
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_collection_persistent_volume' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_collection_persistent_volume {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespace
#
# 
# 
# @param string $name name of the Namespace (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Namespace',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespace' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespace {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespace");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_config_map
#
# 
# 
# @param string $name name of the ConfigMap (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ConfigMap',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_config_map' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_config_map {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_config_map");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_config_map");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/configmaps/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_endpoints
#
# 
# 
# @param string $name name of the Endpoints (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Endpoints',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_endpoints' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_endpoints {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_endpoints");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_endpoints");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/endpoints/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_event
#
# 
# 
# @param string $name name of the Event (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Event',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_event' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_event {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_event");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_event");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/events/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_limit_range
#
# 
# 
# @param string $name name of the LimitRange (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the LimitRange',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_limit_range' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_limit_range {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_limit_range");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_limit_range");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/limitranges/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_persistent_volume_claim
#
# 
# 
# @param string $name name of the PersistentVolumeClaim (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolumeClaim',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_persistent_volume_claim' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_persistent_volume_claim {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_persistent_volume_claim");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_persistent_volume_claim");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_pod
#
# 
# 
# @param string $name name of the Pod (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Pod',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_pod' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_pod {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_pod");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_pod");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_pod_template
#
# 
# 
# @param string $name name of the PodTemplate (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodTemplate',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_pod_template' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_pod_template {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_pod_template");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_pod_template");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/podtemplates/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_replication_controller
#
# 
# 
# @param string $name name of the ReplicationController (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ReplicationController',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_replication_controller' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_replication_controller {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_replication_controller");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_replication_controller");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_resource_quota
#
# 
# 
# @param string $name name of the ResourceQuota (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ResourceQuota',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_resource_quota' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_resource_quota {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_resource_quota");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_resource_quota");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_secret
#
# 
# 
# @param string $name name of the Secret (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Secret',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_secret' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_secret {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_secret");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_secret");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/secrets/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_service
#
# 
# 
# @param string $name name of the Service (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Service',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_service' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_service {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_service");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_service");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_namespaced_service_account
#
# 
# 
# @param string $name name of the ServiceAccount (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceAccount',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_namespaced_service_account' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_namespaced_service_account {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_namespaced_service_account");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling delete_namespaced_service_account");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_node
#
# 
# 
# @param string $name name of the Node (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Node',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_node' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_node {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_node");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# delete_persistent_volume
#
# 
# 
# @param string $name name of the PersistentVolume (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
# @param boolean $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
# @param string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground. (optional)
# @param V1DeleteOptions $body  (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolume',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'grace_period_seconds' => {
        data_type => 'int',
        description => 'The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.',
        required => '0',
    },
    'orphan_dependents' => {
        data_type => 'boolean',
        description => 'Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.',
        required => '0',
    },
    'propagation_policy' => {
        data_type => 'string',
        description => 'Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.',
        required => '0',
    },
    'body' => {
        data_type => 'V1DeleteOptions',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_persistent_volume' } = { 
        summary => '',
        params => $params,
        returns => 'V1Status',
        };
}
# @return V1Status
#
sub delete_persistent_volume {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling delete_persistent_volume");
    }

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'grace_period_seconds'}) {
        $query_params->{'gracePeriodSeconds'} = $self->{api_client}->to_query_value($args{'grace_period_seconds'});
    }

    # query params
    if ( exists $args{'orphan_dependents'}) {
        $query_params->{'orphanDependents'} = $self->{api_client}->to_query_value($args{'orphan_dependents'});
    }

    # query params
    if ( exists $args{'propagation_policy'}) {
        $query_params->{'propagationPolicy'} = $self->{api_client}->to_query_value($args{'propagation_policy'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Status', $response);
    return $_response_object;
}

#
# get_api_resources
#
# 
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_api_resources' } = { 
        summary => '',
        params => $params,
        returns => 'V1APIResourceList',
        };
}
# @return V1APIResourceList
#
sub get_api_resources {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1APIResourceList', $response);
    return $_response_object;
}

#
# list_component_status
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_component_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1ComponentStatusList',
        };
}
# @return V1ComponentStatusList
#
sub list_component_status {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/componentstatuses';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ComponentStatusList', $response);
    return $_response_object;
}

#
# list_config_map_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_config_map_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1ConfigMapList',
        };
}
# @return V1ConfigMapList
#
sub list_config_map_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/configmaps';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ConfigMapList', $response);
    return $_response_object;
}

#
# list_endpoints_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_endpoints_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1EndpointsList',
        };
}
# @return V1EndpointsList
#
sub list_endpoints_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/endpoints';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1EndpointsList', $response);
    return $_response_object;
}

#
# list_event_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_event_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1EventList',
        };
}
# @return V1EventList
#
sub list_event_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/events';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1EventList', $response);
    return $_response_object;
}

#
# list_limit_range_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_limit_range_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1LimitRangeList',
        };
}
# @return V1LimitRangeList
#
sub list_limit_range_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/limitranges';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1LimitRangeList', $response);
    return $_response_object;
}

#
# list_namespace
#
# 
# 
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespace' } = { 
        summary => '',
        params => $params,
        returns => 'V1NamespaceList',
        };
}
# @return V1NamespaceList
#
sub list_namespace {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/namespaces';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1NamespaceList', $response);
    return $_response_object;
}

#
# list_namespaced_config_map
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_config_map' } = { 
        summary => '',
        params => $params,
        returns => 'V1ConfigMapList',
        };
}
# @return V1ConfigMapList
#
sub list_namespaced_config_map {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_config_map");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/configmaps';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ConfigMapList', $response);
    return $_response_object;
}

#
# list_namespaced_endpoints
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_endpoints' } = { 
        summary => '',
        params => $params,
        returns => 'V1EndpointsList',
        };
}
# @return V1EndpointsList
#
sub list_namespaced_endpoints {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_endpoints");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/endpoints';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1EndpointsList', $response);
    return $_response_object;
}

#
# list_namespaced_event
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_event' } = { 
        summary => '',
        params => $params,
        returns => 'V1EventList',
        };
}
# @return V1EventList
#
sub list_namespaced_event {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_event");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/events';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1EventList', $response);
    return $_response_object;
}

#
# list_namespaced_limit_range
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_limit_range' } = { 
        summary => '',
        params => $params,
        returns => 'V1LimitRangeList',
        };
}
# @return V1LimitRangeList
#
sub list_namespaced_limit_range {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_limit_range");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/limitranges';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1LimitRangeList', $response);
    return $_response_object;
}

#
# list_namespaced_persistent_volume_claim
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_persistent_volume_claim' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeClaimList',
        };
}
# @return V1PersistentVolumeClaimList
#
sub list_namespaced_persistent_volume_claim {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_persistent_volume_claim");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeClaimList', $response);
    return $_response_object;
}

#
# list_namespaced_pod
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_pod' } = { 
        summary => '',
        params => $params,
        returns => 'V1PodList',
        };
}
# @return V1PodList
#
sub list_namespaced_pod {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_pod");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PodList', $response);
    return $_response_object;
}

#
# list_namespaced_pod_template
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_pod_template' } = { 
        summary => '',
        params => $params,
        returns => 'V1PodTemplateList',
        };
}
# @return V1PodTemplateList
#
sub list_namespaced_pod_template {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_pod_template");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/podtemplates';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PodTemplateList', $response);
    return $_response_object;
}

#
# list_namespaced_replication_controller
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_replication_controller' } = { 
        summary => '',
        params => $params,
        returns => 'V1ReplicationControllerList',
        };
}
# @return V1ReplicationControllerList
#
sub list_namespaced_replication_controller {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_replication_controller");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ReplicationControllerList', $response);
    return $_response_object;
}

#
# list_namespaced_resource_quota
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_resource_quota' } = { 
        summary => '',
        params => $params,
        returns => 'V1ResourceQuotaList',
        };
}
# @return V1ResourceQuotaList
#
sub list_namespaced_resource_quota {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_resource_quota");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ResourceQuotaList', $response);
    return $_response_object;
}

#
# list_namespaced_secret
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_secret' } = { 
        summary => '',
        params => $params,
        returns => 'V1SecretList',
        };
}
# @return V1SecretList
#
sub list_namespaced_secret {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_secret");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/secrets';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1SecretList', $response);
    return $_response_object;
}

#
# list_namespaced_service
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_service' } = { 
        summary => '',
        params => $params,
        returns => 'V1ServiceList',
        };
}
# @return V1ServiceList
#
sub list_namespaced_service {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_service");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ServiceList', $response);
    return $_response_object;
}

#
# list_namespaced_service_account
#
# 
# 
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_namespaced_service_account' } = { 
        summary => '',
        params => $params,
        returns => 'V1ServiceAccountList',
        };
}
# @return V1ServiceAccountList
#
sub list_namespaced_service_account {
    my ($self, %args) = @_;

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling list_namespaced_service_account");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ServiceAccountList', $response);
    return $_response_object;
}

#
# list_node
#
# 
# 
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_node' } = { 
        summary => '',
        params => $params,
        returns => 'V1NodeList',
        };
}
# @return V1NodeList
#
sub list_node {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/nodes';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1NodeList', $response);
    return $_response_object;
}

#
# list_persistent_volume
#
# 
# 
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_persistent_volume' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeList',
        };
}
# @return V1PersistentVolumeList
#
sub list_persistent_volume {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeList', $response);
    return $_response_object;
}

#
# list_persistent_volume_claim_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_persistent_volume_claim_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeClaimList',
        };
}
# @return V1PersistentVolumeClaimList
#
sub list_persistent_volume_claim_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumeclaims';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeClaimList', $response);
    return $_response_object;
}

#
# list_pod_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_pod_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1PodList',
        };
}
# @return V1PodList
#
sub list_pod_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/pods';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PodList', $response);
    return $_response_object;
}

#
# list_pod_template_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_pod_template_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1PodTemplateList',
        };
}
# @return V1PodTemplateList
#
sub list_pod_template_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/podtemplates';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PodTemplateList', $response);
    return $_response_object;
}

#
# list_replication_controller_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_replication_controller_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1ReplicationControllerList',
        };
}
# @return V1ReplicationControllerList
#
sub list_replication_controller_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/replicationcontrollers';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ReplicationControllerList', $response);
    return $_response_object;
}

#
# list_resource_quota_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_resource_quota_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1ResourceQuotaList',
        };
}
# @return V1ResourceQuotaList
#
sub list_resource_quota_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/resourcequotas';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ResourceQuotaList', $response);
    return $_response_object;
}

#
# list_secret_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_secret_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1SecretList',
        };
}
# @return V1SecretList
#
sub list_secret_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/secrets';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1SecretList', $response);
    return $_response_object;
}

#
# list_service_account_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_service_account_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1ServiceAccountList',
        };
}
# @return V1ServiceAccountList
#
sub list_service_account_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/serviceaccounts';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ServiceAccountList', $response);
    return $_response_object;
}

#
# list_service_for_all_namespaces
#
# 
# 
# @param string $continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
# @param string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
# @param string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
# @param int $limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
# @param int $timeout_seconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)
# @param boolean $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
{
    my $params = {
    'continue' => {
        data_type => 'string',
        description => 'The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.',
        required => '0',
    },
    'field_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their fields. Defaults to everything.',
        required => '0',
    },
    'label_selector' => {
        data_type => 'string',
        description => 'A selector to restrict the list of returned objects by their labels. Defaults to everything.',
        required => '0',
    },
    'limit' => {
        data_type => 'int',
        description => 'limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'resource_version' => {
        data_type => 'string',
        description => 'When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.',
        required => '0',
    },
    'timeout_seconds' => {
        data_type => 'int',
        description => 'Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.',
        required => '0',
    },
    'watch' => {
        data_type => 'boolean',
        description => 'Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'list_service_for_all_namespaces' } = { 
        summary => '',
        params => $params,
        returns => 'V1ServiceList',
        };
}
# @return V1ServiceList
#
sub list_service_for_all_namespaces {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/api/v1/services';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'continue'}) {
        $query_params->{'continue'} = $self->{api_client}->to_query_value($args{'continue'});
    }

    # query params
    if ( exists $args{'field_selector'}) {
        $query_params->{'fieldSelector'} = $self->{api_client}->to_query_value($args{'field_selector'});
    }

    # query params
    if ( exists $args{'label_selector'}) {
        $query_params->{'labelSelector'} = $self->{api_client}->to_query_value($args{'label_selector'});
    }

    # query params
    if ( exists $args{'limit'}) {
        $query_params->{'limit'} = $self->{api_client}->to_query_value($args{'limit'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'resource_version'}) {
        $query_params->{'resourceVersion'} = $self->{api_client}->to_query_value($args{'resource_version'});
    }

    # query params
    if ( exists $args{'timeout_seconds'}) {
        $query_params->{'timeoutSeconds'} = $self->{api_client}->to_query_value($args{'timeout_seconds'});
    }

    # query params
    if ( exists $args{'watch'}) {
        $query_params->{'watch'} = $self->{api_client}->to_query_value($args{'watch'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ServiceList', $response);
    return $_response_object;
}

#
# patch_namespace
#
# 
# 
# @param string $name name of the Namespace (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Namespace',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespace' } = { 
        summary => '',
        params => $params,
        returns => 'V1Namespace',
        };
}
# @return V1Namespace
#
sub patch_namespace {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespace");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespace");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Namespace', $response);
    return $_response_object;
}

#
# patch_namespace_status
#
# 
# 
# @param string $name name of the Namespace (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Namespace',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespace_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Namespace',
        };
}
# @return V1Namespace
#
sub patch_namespace_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespace_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespace_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{name}/status';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Namespace', $response);
    return $_response_object;
}

#
# patch_namespaced_config_map
#
# 
# 
# @param string $name name of the ConfigMap (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ConfigMap',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_config_map' } = { 
        summary => '',
        params => $params,
        returns => 'V1ConfigMap',
        };
}
# @return V1ConfigMap
#
sub patch_namespaced_config_map {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_config_map");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_config_map");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_config_map");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/configmaps/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ConfigMap', $response);
    return $_response_object;
}

#
# patch_namespaced_endpoints
#
# 
# 
# @param string $name name of the Endpoints (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Endpoints',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_endpoints' } = { 
        summary => '',
        params => $params,
        returns => 'V1Endpoints',
        };
}
# @return V1Endpoints
#
sub patch_namespaced_endpoints {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_endpoints");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_endpoints");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_endpoints");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/endpoints/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Endpoints', $response);
    return $_response_object;
}

#
# patch_namespaced_event
#
# 
# 
# @param string $name name of the Event (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Event',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_event' } = { 
        summary => '',
        params => $params,
        returns => 'V1Event',
        };
}
# @return V1Event
#
sub patch_namespaced_event {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_event");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_event");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_event");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/events/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Event', $response);
    return $_response_object;
}

#
# patch_namespaced_limit_range
#
# 
# 
# @param string $name name of the LimitRange (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the LimitRange',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_limit_range' } = { 
        summary => '',
        params => $params,
        returns => 'V1LimitRange',
        };
}
# @return V1LimitRange
#
sub patch_namespaced_limit_range {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_limit_range");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_limit_range");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_limit_range");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/limitranges/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1LimitRange', $response);
    return $_response_object;
}

#
# patch_namespaced_persistent_volume_claim
#
# 
# 
# @param string $name name of the PersistentVolumeClaim (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolumeClaim',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_persistent_volume_claim' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeClaim',
        };
}
# @return V1PersistentVolumeClaim
#
sub patch_namespaced_persistent_volume_claim {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_persistent_volume_claim");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_persistent_volume_claim");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_persistent_volume_claim");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeClaim', $response);
    return $_response_object;
}

#
# patch_namespaced_persistent_volume_claim_status
#
# 
# 
# @param string $name name of the PersistentVolumeClaim (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolumeClaim',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_persistent_volume_claim_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeClaim',
        };
}
# @return V1PersistentVolumeClaim
#
sub patch_namespaced_persistent_volume_claim_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_persistent_volume_claim_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_persistent_volume_claim_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_persistent_volume_claim_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeClaim', $response);
    return $_response_object;
}

#
# patch_namespaced_pod
#
# 
# 
# @param string $name name of the Pod (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Pod',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_pod' } = { 
        summary => '',
        params => $params,
        returns => 'V1Pod',
        };
}
# @return V1Pod
#
sub patch_namespaced_pod {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_pod");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_pod");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_pod");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Pod', $response);
    return $_response_object;
}

#
# patch_namespaced_pod_status
#
# 
# 
# @param string $name name of the Pod (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Pod',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_pod_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Pod',
        };
}
# @return V1Pod
#
sub patch_namespaced_pod_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_pod_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_pod_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_pod_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/status';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Pod', $response);
    return $_response_object;
}

#
# patch_namespaced_pod_template
#
# 
# 
# @param string $name name of the PodTemplate (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodTemplate',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_pod_template' } = { 
        summary => '',
        params => $params,
        returns => 'V1PodTemplate',
        };
}
# @return V1PodTemplate
#
sub patch_namespaced_pod_template {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_pod_template");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_pod_template");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_pod_template");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/podtemplates/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PodTemplate', $response);
    return $_response_object;
}

#
# patch_namespaced_replication_controller
#
# 
# 
# @param string $name name of the ReplicationController (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ReplicationController',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_replication_controller' } = { 
        summary => '',
        params => $params,
        returns => 'V1ReplicationController',
        };
}
# @return V1ReplicationController
#
sub patch_namespaced_replication_controller {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_replication_controller");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_replication_controller");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_replication_controller");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ReplicationController', $response);
    return $_response_object;
}

#
# patch_namespaced_replication_controller_scale
#
# 
# 
# @param string $name name of the Scale (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Scale',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_replication_controller_scale' } = { 
        summary => '',
        params => $params,
        returns => 'V1Scale',
        };
}
# @return V1Scale
#
sub patch_namespaced_replication_controller_scale {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_replication_controller_scale");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_replication_controller_scale");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_replication_controller_scale");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Scale', $response);
    return $_response_object;
}

#
# patch_namespaced_replication_controller_status
#
# 
# 
# @param string $name name of the ReplicationController (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ReplicationController',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_replication_controller_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1ReplicationController',
        };
}
# @return V1ReplicationController
#
sub patch_namespaced_replication_controller_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_replication_controller_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_replication_controller_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_replication_controller_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ReplicationController', $response);
    return $_response_object;
}

#
# patch_namespaced_resource_quota
#
# 
# 
# @param string $name name of the ResourceQuota (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ResourceQuota',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_resource_quota' } = { 
        summary => '',
        params => $params,
        returns => 'V1ResourceQuota',
        };
}
# @return V1ResourceQuota
#
sub patch_namespaced_resource_quota {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_resource_quota");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_resource_quota");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_resource_quota");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ResourceQuota', $response);
    return $_response_object;
}

#
# patch_namespaced_resource_quota_status
#
# 
# 
# @param string $name name of the ResourceQuota (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ResourceQuota',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_resource_quota_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1ResourceQuota',
        };
}
# @return V1ResourceQuota
#
sub patch_namespaced_resource_quota_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_resource_quota_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_resource_quota_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_resource_quota_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ResourceQuota', $response);
    return $_response_object;
}

#
# patch_namespaced_secret
#
# 
# 
# @param string $name name of the Secret (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Secret',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_secret' } = { 
        summary => '',
        params => $params,
        returns => 'V1Secret',
        };
}
# @return V1Secret
#
sub patch_namespaced_secret {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_secret");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_secret");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_secret");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/secrets/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Secret', $response);
    return $_response_object;
}

#
# patch_namespaced_service
#
# 
# 
# @param string $name name of the Service (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Service',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_service' } = { 
        summary => '',
        params => $params,
        returns => 'V1Service',
        };
}
# @return V1Service
#
sub patch_namespaced_service {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_service");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_service");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_service");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Service', $response);
    return $_response_object;
}

#
# patch_namespaced_service_account
#
# 
# 
# @param string $name name of the ServiceAccount (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceAccount',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_service_account' } = { 
        summary => '',
        params => $params,
        returns => 'V1ServiceAccount',
        };
}
# @return V1ServiceAccount
#
sub patch_namespaced_service_account {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_service_account");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_service_account");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_service_account");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ServiceAccount', $response);
    return $_response_object;
}

#
# patch_namespaced_service_status
#
# 
# 
# @param string $name name of the Service (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Service',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_namespaced_service_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Service',
        };
}
# @return V1Service
#
sub patch_namespaced_service_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_namespaced_service_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling patch_namespaced_service_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_namespaced_service_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/status';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Service', $response);
    return $_response_object;
}

#
# patch_node
#
# 
# 
# @param string $name name of the Node (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Node',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_node' } = { 
        summary => '',
        params => $params,
        returns => 'V1Node',
        };
}
# @return V1Node
#
sub patch_node {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_node");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_node");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Node', $response);
    return $_response_object;
}

#
# patch_node_status
#
# 
# 
# @param string $name name of the Node (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Node',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_node_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Node',
        };
}
# @return V1Node
#
sub patch_node_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_node_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_node_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/status';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Node', $response);
    return $_response_object;
}

#
# patch_persistent_volume
#
# 
# 
# @param string $name name of the PersistentVolume (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolume',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_persistent_volume' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolume',
        };
}
# @return V1PersistentVolume
#
sub patch_persistent_volume {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_persistent_volume");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_persistent_volume");
    }

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolume', $response);
    return $_response_object;
}

#
# patch_persistent_volume_status
#
# 
# 
# @param string $name name of the PersistentVolume (required)
# @param object $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). (optional)
# @param boolean $force Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolume',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).',
        required => '0',
    },
    'force' => {
        data_type => 'boolean',
        description => 'Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'patch_persistent_volume_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolume',
        };
}
# @return V1PersistentVolume
#
sub patch_persistent_volume_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling patch_persistent_volume_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling patch_persistent_volume_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes/{name}/status';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json');

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'force'}) {
        $query_params->{'force'} = $self->{api_client}->to_query_value($args{'force'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolume', $response);
    return $_response_object;
}

#
# read_component_status
#
# 
# 
# @param string $name name of the ComponentStatus (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ComponentStatus',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_component_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1ComponentStatus',
        };
}
# @return V1ComponentStatus
#
sub read_component_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_component_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/componentstatuses/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ComponentStatus', $response);
    return $_response_object;
}

#
# read_namespace
#
# 
# 
# @param string $name name of the Namespace (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Namespace',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespace' } = { 
        summary => '',
        params => $params,
        returns => 'V1Namespace',
        };
}
# @return V1Namespace
#
sub read_namespace {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespace");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Namespace', $response);
    return $_response_object;
}

#
# read_namespace_status
#
# 
# 
# @param string $name name of the Namespace (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Namespace',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespace_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Namespace',
        };
}
# @return V1Namespace
#
sub read_namespace_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespace_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{name}/status';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Namespace', $response);
    return $_response_object;
}

#
# read_namespaced_config_map
#
# 
# 
# @param string $name name of the ConfigMap (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ConfigMap',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_config_map' } = { 
        summary => '',
        params => $params,
        returns => 'V1ConfigMap',
        };
}
# @return V1ConfigMap
#
sub read_namespaced_config_map {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_config_map");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_config_map");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/configmaps/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ConfigMap', $response);
    return $_response_object;
}

#
# read_namespaced_endpoints
#
# 
# 
# @param string $name name of the Endpoints (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Endpoints',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_endpoints' } = { 
        summary => '',
        params => $params,
        returns => 'V1Endpoints',
        };
}
# @return V1Endpoints
#
sub read_namespaced_endpoints {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_endpoints");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_endpoints");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/endpoints/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Endpoints', $response);
    return $_response_object;
}

#
# read_namespaced_event
#
# 
# 
# @param string $name name of the Event (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Event',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_event' } = { 
        summary => '',
        params => $params,
        returns => 'V1Event',
        };
}
# @return V1Event
#
sub read_namespaced_event {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_event");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_event");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/events/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Event', $response);
    return $_response_object;
}

#
# read_namespaced_limit_range
#
# 
# 
# @param string $name name of the LimitRange (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the LimitRange',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_limit_range' } = { 
        summary => '',
        params => $params,
        returns => 'V1LimitRange',
        };
}
# @return V1LimitRange
#
sub read_namespaced_limit_range {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_limit_range");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_limit_range");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/limitranges/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1LimitRange', $response);
    return $_response_object;
}

#
# read_namespaced_persistent_volume_claim
#
# 
# 
# @param string $name name of the PersistentVolumeClaim (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolumeClaim',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_persistent_volume_claim' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeClaim',
        };
}
# @return V1PersistentVolumeClaim
#
sub read_namespaced_persistent_volume_claim {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_persistent_volume_claim");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_persistent_volume_claim");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeClaim', $response);
    return $_response_object;
}

#
# read_namespaced_persistent_volume_claim_status
#
# 
# 
# @param string $name name of the PersistentVolumeClaim (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolumeClaim',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_persistent_volume_claim_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeClaim',
        };
}
# @return V1PersistentVolumeClaim
#
sub read_namespaced_persistent_volume_claim_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_persistent_volume_claim_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_persistent_volume_claim_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeClaim', $response);
    return $_response_object;
}

#
# read_namespaced_pod
#
# 
# 
# @param string $name name of the Pod (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Pod',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_pod' } = { 
        summary => '',
        params => $params,
        returns => 'V1Pod',
        };
}
# @return V1Pod
#
sub read_namespaced_pod {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_pod");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_pod");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Pod', $response);
    return $_response_object;
}

#
# read_namespaced_pod_log
#
# 
# 
# @param string $name name of the Pod (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $container The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)
# @param boolean $follow Follow the log stream of the pod. Defaults to false. (optional)
# @param int $limit_bytes If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $previous Return previous terminated container logs. Defaults to false. (optional)
# @param int $since_seconds A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)
# @param int $tail_lines If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)
# @param boolean $timestamps If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Pod',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'container' => {
        data_type => 'string',
        description => 'The container for which to stream logs. Defaults to only container if there is one container in the pod.',
        required => '0',
    },
    'follow' => {
        data_type => 'boolean',
        description => 'Follow the log stream of the pod. Defaults to false.',
        required => '0',
    },
    'limit_bytes' => {
        data_type => 'int',
        description => 'If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'previous' => {
        data_type => 'boolean',
        description => 'Return previous terminated container logs. Defaults to false.',
        required => '0',
    },
    'since_seconds' => {
        data_type => 'int',
        description => 'A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.',
        required => '0',
    },
    'tail_lines' => {
        data_type => 'int',
        description => 'If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime',
        required => '0',
    },
    'timestamps' => {
        data_type => 'boolean',
        description => 'If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_pod_log' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub read_namespaced_pod_log {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_pod_log");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_pod_log");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/log';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'container'}) {
        $query_params->{'container'} = $self->{api_client}->to_query_value($args{'container'});
    }

    # query params
    if ( exists $args{'follow'}) {
        $query_params->{'follow'} = $self->{api_client}->to_query_value($args{'follow'});
    }

    # query params
    if ( exists $args{'limit_bytes'}) {
        $query_params->{'limitBytes'} = $self->{api_client}->to_query_value($args{'limit_bytes'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'previous'}) {
        $query_params->{'previous'} = $self->{api_client}->to_query_value($args{'previous'});
    }

    # query params
    if ( exists $args{'since_seconds'}) {
        $query_params->{'sinceSeconds'} = $self->{api_client}->to_query_value($args{'since_seconds'});
    }

    # query params
    if ( exists $args{'tail_lines'}) {
        $query_params->{'tailLines'} = $self->{api_client}->to_query_value($args{'tail_lines'});
    }

    # query params
    if ( exists $args{'timestamps'}) {
        $query_params->{'timestamps'} = $self->{api_client}->to_query_value($args{'timestamps'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# read_namespaced_pod_status
#
# 
# 
# @param string $name name of the Pod (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Pod',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_pod_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Pod',
        };
}
# @return V1Pod
#
sub read_namespaced_pod_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_pod_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_pod_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/status';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Pod', $response);
    return $_response_object;
}

#
# read_namespaced_pod_template
#
# 
# 
# @param string $name name of the PodTemplate (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodTemplate',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_pod_template' } = { 
        summary => '',
        params => $params,
        returns => 'V1PodTemplate',
        };
}
# @return V1PodTemplate
#
sub read_namespaced_pod_template {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_pod_template");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_pod_template");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/podtemplates/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PodTemplate', $response);
    return $_response_object;
}

#
# read_namespaced_replication_controller
#
# 
# 
# @param string $name name of the ReplicationController (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ReplicationController',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_replication_controller' } = { 
        summary => '',
        params => $params,
        returns => 'V1ReplicationController',
        };
}
# @return V1ReplicationController
#
sub read_namespaced_replication_controller {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_replication_controller");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_replication_controller");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ReplicationController', $response);
    return $_response_object;
}

#
# read_namespaced_replication_controller_scale
#
# 
# 
# @param string $name name of the Scale (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Scale',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_replication_controller_scale' } = { 
        summary => '',
        params => $params,
        returns => 'V1Scale',
        };
}
# @return V1Scale
#
sub read_namespaced_replication_controller_scale {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_replication_controller_scale");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_replication_controller_scale");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Scale', $response);
    return $_response_object;
}

#
# read_namespaced_replication_controller_status
#
# 
# 
# @param string $name name of the ReplicationController (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ReplicationController',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_replication_controller_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1ReplicationController',
        };
}
# @return V1ReplicationController
#
sub read_namespaced_replication_controller_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_replication_controller_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_replication_controller_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ReplicationController', $response);
    return $_response_object;
}

#
# read_namespaced_resource_quota
#
# 
# 
# @param string $name name of the ResourceQuota (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ResourceQuota',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_resource_quota' } = { 
        summary => '',
        params => $params,
        returns => 'V1ResourceQuota',
        };
}
# @return V1ResourceQuota
#
sub read_namespaced_resource_quota {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_resource_quota");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_resource_quota");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ResourceQuota', $response);
    return $_response_object;
}

#
# read_namespaced_resource_quota_status
#
# 
# 
# @param string $name name of the ResourceQuota (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ResourceQuota',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_resource_quota_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1ResourceQuota',
        };
}
# @return V1ResourceQuota
#
sub read_namespaced_resource_quota_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_resource_quota_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_resource_quota_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ResourceQuota', $response);
    return $_response_object;
}

#
# read_namespaced_secret
#
# 
# 
# @param string $name name of the Secret (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Secret',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_secret' } = { 
        summary => '',
        params => $params,
        returns => 'V1Secret',
        };
}
# @return V1Secret
#
sub read_namespaced_secret {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_secret");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_secret");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/secrets/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Secret', $response);
    return $_response_object;
}

#
# read_namespaced_service
#
# 
# 
# @param string $name name of the Service (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Service',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_service' } = { 
        summary => '',
        params => $params,
        returns => 'V1Service',
        };
}
# @return V1Service
#
sub read_namespaced_service {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_service");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_service");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Service', $response);
    return $_response_object;
}

#
# read_namespaced_service_account
#
# 
# 
# @param string $name name of the ServiceAccount (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceAccount',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_service_account' } = { 
        summary => '',
        params => $params,
        returns => 'V1ServiceAccount',
        };
}
# @return V1ServiceAccount
#
sub read_namespaced_service_account {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_service_account");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_service_account");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ServiceAccount', $response);
    return $_response_object;
}

#
# read_namespaced_service_status
#
# 
# 
# @param string $name name of the Service (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Service',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_namespaced_service_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Service',
        };
}
# @return V1Service
#
sub read_namespaced_service_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_namespaced_service_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling read_namespaced_service_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/status';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Service', $response);
    return $_response_object;
}

#
# read_node
#
# 
# 
# @param string $name name of the Node (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Node',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_node' } = { 
        summary => '',
        params => $params,
        returns => 'V1Node',
        };
}
# @return V1Node
#
sub read_node {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_node");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Node', $response);
    return $_response_object;
}

#
# read_node_status
#
# 
# 
# @param string $name name of the Node (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Node',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_node_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Node',
        };
}
# @return V1Node
#
sub read_node_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_node_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/status';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Node', $response);
    return $_response_object;
}

#
# read_persistent_volume
#
# 
# 
# @param string $name name of the PersistentVolume (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param boolean $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18. (optional)
# @param boolean $export Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolume',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'exact' => {
        data_type => 'boolean',
        description => 'Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    'export' => {
        data_type => 'boolean',
        description => 'Should this value be exported.  Export strips fields that a user can not specify. Deprecated. Planned for removal in 1.18.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_persistent_volume' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolume',
        };
}
# @return V1PersistentVolume
#
sub read_persistent_volume {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_persistent_volume");
    }

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes/{name}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'exact'}) {
        $query_params->{'exact'} = $self->{api_client}->to_query_value($args{'exact'});
    }

    # query params
    if ( exists $args{'export'}) {
        $query_params->{'export'} = $self->{api_client}->to_query_value($args{'export'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolume', $response);
    return $_response_object;
}

#
# read_persistent_volume_status
#
# 
# 
# @param string $name name of the PersistentVolume (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolume',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'read_persistent_volume_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolume',
        };
}
# @return V1PersistentVolume
#
sub read_persistent_volume_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling read_persistent_volume_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes/{name}/status';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolume', $response);
    return $_response_object;
}

#
# replace_namespace
#
# 
# 
# @param string $name name of the Namespace (required)
# @param V1Namespace $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Namespace',
        required => '1',
    },
    'body' => {
        data_type => 'V1Namespace',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespace' } = { 
        summary => '',
        params => $params,
        returns => 'V1Namespace',
        };
}
# @return V1Namespace
#
sub replace_namespace {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespace");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespace");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Namespace', $response);
    return $_response_object;
}

#
# replace_namespace_finalize
#
# 
# 
# @param string $name name of the Namespace (required)
# @param V1Namespace $body  (required)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Namespace',
        required => '1',
    },
    'body' => {
        data_type => 'V1Namespace',
        description => '',
        required => '1',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespace_finalize' } = { 
        summary => '',
        params => $params,
        returns => 'V1Namespace',
        };
}
# @return V1Namespace
#
sub replace_namespace_finalize {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespace_finalize");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespace_finalize");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{name}/finalize';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Namespace', $response);
    return $_response_object;
}

#
# replace_namespace_status
#
# 
# 
# @param string $name name of the Namespace (required)
# @param V1Namespace $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Namespace',
        required => '1',
    },
    'body' => {
        data_type => 'V1Namespace',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespace_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Namespace',
        };
}
# @return V1Namespace
#
sub replace_namespace_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespace_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespace_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{name}/status';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Namespace', $response);
    return $_response_object;
}

#
# replace_namespaced_config_map
#
# 
# 
# @param string $name name of the ConfigMap (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ConfigMap $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ConfigMap',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ConfigMap',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_config_map' } = { 
        summary => '',
        params => $params,
        returns => 'V1ConfigMap',
        };
}
# @return V1ConfigMap
#
sub replace_namespaced_config_map {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_config_map");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_config_map");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_config_map");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/configmaps/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ConfigMap', $response);
    return $_response_object;
}

#
# replace_namespaced_endpoints
#
# 
# 
# @param string $name name of the Endpoints (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Endpoints $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Endpoints',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Endpoints',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_endpoints' } = { 
        summary => '',
        params => $params,
        returns => 'V1Endpoints',
        };
}
# @return V1Endpoints
#
sub replace_namespaced_endpoints {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_endpoints");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_endpoints");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_endpoints");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/endpoints/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Endpoints', $response);
    return $_response_object;
}

#
# replace_namespaced_event
#
# 
# 
# @param string $name name of the Event (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Event $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Event',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Event',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_event' } = { 
        summary => '',
        params => $params,
        returns => 'V1Event',
        };
}
# @return V1Event
#
sub replace_namespaced_event {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_event");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_event");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_event");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/events/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Event', $response);
    return $_response_object;
}

#
# replace_namespaced_limit_range
#
# 
# 
# @param string $name name of the LimitRange (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1LimitRange $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the LimitRange',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1LimitRange',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_limit_range' } = { 
        summary => '',
        params => $params,
        returns => 'V1LimitRange',
        };
}
# @return V1LimitRange
#
sub replace_namespaced_limit_range {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_limit_range");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_limit_range");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_limit_range");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/limitranges/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1LimitRange', $response);
    return $_response_object;
}

#
# replace_namespaced_persistent_volume_claim
#
# 
# 
# @param string $name name of the PersistentVolumeClaim (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1PersistentVolumeClaim $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolumeClaim',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1PersistentVolumeClaim',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_persistent_volume_claim' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeClaim',
        };
}
# @return V1PersistentVolumeClaim
#
sub replace_namespaced_persistent_volume_claim {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_persistent_volume_claim");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_persistent_volume_claim");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_persistent_volume_claim");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeClaim', $response);
    return $_response_object;
}

#
# replace_namespaced_persistent_volume_claim_status
#
# 
# 
# @param string $name name of the PersistentVolumeClaim (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1PersistentVolumeClaim $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolumeClaim',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1PersistentVolumeClaim',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_persistent_volume_claim_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolumeClaim',
        };
}
# @return V1PersistentVolumeClaim
#
sub replace_namespaced_persistent_volume_claim_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_persistent_volume_claim_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_persistent_volume_claim_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_persistent_volume_claim_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolumeClaim', $response);
    return $_response_object;
}

#
# replace_namespaced_pod
#
# 
# 
# @param string $name name of the Pod (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Pod $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Pod',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Pod',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_pod' } = { 
        summary => '',
        params => $params,
        returns => 'V1Pod',
        };
}
# @return V1Pod
#
sub replace_namespaced_pod {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_pod");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_pod");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_pod");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Pod', $response);
    return $_response_object;
}

#
# replace_namespaced_pod_status
#
# 
# 
# @param string $name name of the Pod (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Pod $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Pod',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Pod',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_pod_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Pod',
        };
}
# @return V1Pod
#
sub replace_namespaced_pod_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_pod_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_pod_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_pod_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/status';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Pod', $response);
    return $_response_object;
}

#
# replace_namespaced_pod_template
#
# 
# 
# @param string $name name of the PodTemplate (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1PodTemplate $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PodTemplate',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1PodTemplate',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_pod_template' } = { 
        summary => '',
        params => $params,
        returns => 'V1PodTemplate',
        };
}
# @return V1PodTemplate
#
sub replace_namespaced_pod_template {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_pod_template");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_pod_template");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_pod_template");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/podtemplates/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PodTemplate', $response);
    return $_response_object;
}

#
# replace_namespaced_replication_controller
#
# 
# 
# @param string $name name of the ReplicationController (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ReplicationController $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ReplicationController',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ReplicationController',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_replication_controller' } = { 
        summary => '',
        params => $params,
        returns => 'V1ReplicationController',
        };
}
# @return V1ReplicationController
#
sub replace_namespaced_replication_controller {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_replication_controller");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_replication_controller");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_replication_controller");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ReplicationController', $response);
    return $_response_object;
}

#
# replace_namespaced_replication_controller_scale
#
# 
# 
# @param string $name name of the Scale (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Scale $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Scale',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Scale',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_replication_controller_scale' } = { 
        summary => '',
        params => $params,
        returns => 'V1Scale',
        };
}
# @return V1Scale
#
sub replace_namespaced_replication_controller_scale {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_replication_controller_scale");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_replication_controller_scale");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_replication_controller_scale");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Scale', $response);
    return $_response_object;
}

#
# replace_namespaced_replication_controller_status
#
# 
# 
# @param string $name name of the ReplicationController (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ReplicationController $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ReplicationController',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ReplicationController',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_replication_controller_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1ReplicationController',
        };
}
# @return V1ReplicationController
#
sub replace_namespaced_replication_controller_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_replication_controller_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_replication_controller_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_replication_controller_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ReplicationController', $response);
    return $_response_object;
}

#
# replace_namespaced_resource_quota
#
# 
# 
# @param string $name name of the ResourceQuota (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ResourceQuota $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ResourceQuota',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ResourceQuota',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_resource_quota' } = { 
        summary => '',
        params => $params,
        returns => 'V1ResourceQuota',
        };
}
# @return V1ResourceQuota
#
sub replace_namespaced_resource_quota {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_resource_quota");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_resource_quota");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_resource_quota");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ResourceQuota', $response);
    return $_response_object;
}

#
# replace_namespaced_resource_quota_status
#
# 
# 
# @param string $name name of the ResourceQuota (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ResourceQuota $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ResourceQuota',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ResourceQuota',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_resource_quota_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1ResourceQuota',
        };
}
# @return V1ResourceQuota
#
sub replace_namespaced_resource_quota_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_resource_quota_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_resource_quota_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_resource_quota_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ResourceQuota', $response);
    return $_response_object;
}

#
# replace_namespaced_secret
#
# 
# 
# @param string $name name of the Secret (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Secret $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Secret',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Secret',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_secret' } = { 
        summary => '',
        params => $params,
        returns => 'V1Secret',
        };
}
# @return V1Secret
#
sub replace_namespaced_secret {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_secret");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_secret");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_secret");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/secrets/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Secret', $response);
    return $_response_object;
}

#
# replace_namespaced_service
#
# 
# 
# @param string $name name of the Service (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Service $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Service',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Service',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_service' } = { 
        summary => '',
        params => $params,
        returns => 'V1Service',
        };
}
# @return V1Service
#
sub replace_namespaced_service {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_service");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_service");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_service");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Service', $response);
    return $_response_object;
}

#
# replace_namespaced_service_account
#
# 
# 
# @param string $name name of the ServiceAccount (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1ServiceAccount $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the ServiceAccount',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1ServiceAccount',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_service_account' } = { 
        summary => '',
        params => $params,
        returns => 'V1ServiceAccount',
        };
}
# @return V1ServiceAccount
#
sub replace_namespaced_service_account {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_service_account");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_service_account");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_service_account");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1ServiceAccount', $response);
    return $_response_object;
}

#
# replace_namespaced_service_status
#
# 
# 
# @param string $name name of the Service (required)
# @param string $namespace object name and auth scope, such as for teams and projects (required)
# @param V1Service $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Service',
        required => '1',
    },
    'namespace' => {
        data_type => 'string',
        description => 'object name and auth scope, such as for teams and projects',
        required => '1',
    },
    'body' => {
        data_type => 'V1Service',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_namespaced_service_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Service',
        };
}
# @return V1Service
#
sub replace_namespaced_service_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_namespaced_service_status");
    }

    # verify the required parameter 'namespace' is set
    unless (exists $args{'namespace'}) {
      croak("Missing the required parameter 'namespace' when calling replace_namespaced_service_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_namespaced_service_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/namespaces/{namespace}/services/{name}/status';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'namespace'}) {
        my $_base_variable = "{" . "namespace" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'namespace'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Service', $response);
    return $_response_object;
}

#
# replace_node
#
# 
# 
# @param string $name name of the Node (required)
# @param V1Node $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Node',
        required => '1',
    },
    'body' => {
        data_type => 'V1Node',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_node' } = { 
        summary => '',
        params => $params,
        returns => 'V1Node',
        };
}
# @return V1Node
#
sub replace_node {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_node");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_node");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Node', $response);
    return $_response_object;
}

#
# replace_node_status
#
# 
# 
# @param string $name name of the Node (required)
# @param V1Node $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the Node',
        required => '1',
    },
    'body' => {
        data_type => 'V1Node',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_node_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1Node',
        };
}
# @return V1Node
#
sub replace_node_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_node_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_node_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/nodes/{name}/status';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1Node', $response);
    return $_response_object;
}

#
# replace_persistent_volume
#
# 
# 
# @param string $name name of the PersistentVolume (required)
# @param V1PersistentVolume $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolume',
        required => '1',
    },
    'body' => {
        data_type => 'V1PersistentVolume',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_persistent_volume' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolume',
        };
}
# @return V1PersistentVolume
#
sub replace_persistent_volume {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_persistent_volume");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_persistent_volume");
    }

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes/{name}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolume', $response);
    return $_response_object;
}

#
# replace_persistent_volume_status
#
# 
# 
# @param string $name name of the PersistentVolume (required)
# @param V1PersistentVolume $body  (required)
# @param string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
# @param string $dry_run When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed (optional)
# @param string $field_manager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. (optional)
{
    my $params = {
    'name' => {
        data_type => 'string',
        description => 'name of the PersistentVolume',
        required => '1',
    },
    'body' => {
        data_type => 'V1PersistentVolume',
        description => '',
        required => '1',
    },
    'pretty' => {
        data_type => 'string',
        description => 'If &#39;true&#39;, then the output is pretty printed.',
        required => '0',
    },
    'dry_run' => {
        data_type => 'string',
        description => 'When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed',
        required => '0',
    },
    'field_manager' => {
        data_type => 'string',
        description => 'fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'replace_persistent_volume_status' } = { 
        summary => '',
        params => $params,
        returns => 'V1PersistentVolume',
        };
}
# @return V1PersistentVolume
#
sub replace_persistent_volume_status {
    my ($self, %args) = @_;

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling replace_persistent_volume_status");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling replace_persistent_volume_status");
    }

    # parse inputs
    my $_resource_path = '/api/v1/persistentvolumes/{name}/status';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'pretty'}) {
        $query_params->{'pretty'} = $self->{api_client}->to_query_value($args{'pretty'});
    }

    # query params
    if ( exists $args{'dry_run'}) {
        $query_params->{'dryRun'} = $self->{api_client}->to_query_value($args{'dry_run'});
    }

    # query params
    if ( exists $args{'field_manager'}) {
        $query_params->{'fieldManager'} = $self->{api_client}->to_query_value($args{'field_manager'});
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerToken )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('V1PersistentVolume', $response);
    return $_response_object;
}

1;
